#  Declarative 5G control plane simulator

A simulator for the 5G UE and control plane interactions using the declarative Î”-controller framework.

## Getting started

You will need the `dctl` command line tool to administer kubeconfigs, obtain it from
[here](https://github.com/l7mp/dcontroller).

### Development

1. Start the operators using unsafe HTTP mode:
   ```bash
   $ go run main.go --http -zap-log-level 4
   ```

2. Create an admin config:
   ```bash
   $ dctl generate-config --http --insecure --user=admin --namespaces="*" > ./admin.config
   ```

3. Make a client request:
   ```bash
   $ export KUBECONFIG=./admin.config
   ```

### Production

1. Generate the TLS certificate:
   ```bash
   $ dctl generate-keys
   ```

2. Start the operators:
   ```bash
   $ go run main.go -insecure -zap-log-level 1
   ```

3. Create **initial UE config**, which will only allow the a UE with name `user-1` to register:
   ```bash
   $ dctl generate-config --user=user-1 --namespaces=user-1 --insecure \
    --rules='[{"verbs":["create","get","list","watch","delete"],"apiGroups":["amf.view.dcontroller.io"],"resources":["registration"]}]' \
    > ./user-1-initial.config
   ```

4. To interact with the API server with **full admin access**, load the config generated as follows:

   ```bash
   $ dctl generate-config --user=<admin> --insecure \
    --rules='[{"verbs":["*"],"apiGroups":["*"],"resources":["*"]}]' \
    > ./admin.config
   ```

## Registration

### The Registration resource

The Registration resource is the main driver for creating UE registrations. The UE specifies the registration parameters in the spec of the Registration resource and the AMF will add a status to indicate the registration status plus some useful info. Note that the annotations are optional, but the spec parameters are mandatory (checked and rejected in missing or invalid)

The below dump shows a full Registration resource with a valid status set by the AMF:

``` yaml
apiVersion: amf.view.dcontroller.io/v1alpha1
kind: Registration
metadata:
  name: user-1
  namespace: user-1
  labels:
    equipment.type: "smartphone"           # Equipment type: enum: smartphone | iot | vehicle | etc
  annotations:
    interface: "N1-NAS-MM"                 # Protocol interface
    ran.node: "gnb-site-4-sector-2"        # RAN information
spec:
  registrationType: initial                # Options: initial | mobility | periodic | emergency
  accessType: "3gpp"                       # enum: 3gpp | non-3gpp | both
  trackingArea: "tai-001-01-000001"        # Registration area (TAI where registration initiated)
  mobileIdentity:
    type: SUCI                             # Options: SUCI | SUPI | GUTI | IMEI | IMEISV | TMSI
    value: "suci-0-999-01-02-4f2a7b9c8d13e7a5c0"
  ueSecurityCapability:
    encryptionAlgorithms:                  # Ordered by preference (first = most preferred)
      - 5G-EA0                             # Null encryption (no protection)
      - 5G-EA1                             # 128-bit SNOW 3G
      - 5G-EA2                             # 128-bit AES
      - 5G-EA3                             # 128-bit ZUC
    integrityAlgorithms:                   # Ordered by preference
      - 5G-IA0                             # Null integrity (no protection)
      - 5G-IA1                             # 128-bit SNOW 3G
      - 5G-IA2                             # 128-bit AES-CMAC
      - 5G-IA3                             # 128-bit ZUC
  ueStatus:
    s1Mode: false                          # EPC/LTE interworking capability
    n1Mode: true                           # 5GC/NR native mode capability
  ueNetworkCapability:                     # LTE/EPS capabilities for interworking
    epsEncryptionAlgorithms:
      - EEA0                               # Options: EEA0, EEA1, EEA2, EEA3
    epsIntegrityAlgorithms:
      - EIA0                               # Options: EIA0, EIA1, EIA2, EIA3
  requestedNSSAI:                          # Requested network slices
    - sliceType: eMBB                      # Options: eMBB | URLLC | MIoT | V2X | custom
      sliceDifferentiator: "000001"        # Optional, for multiple slices of same type
    - sliceType: URLLC                     # Only eMBB (Enhanced Mobile Broadband) is supported
      sliceDifferentiator: "000002"
status:                                    # Set by the AMF
  guti: guti-310-170-3F-152-2A-B7C8D9E0    # GUTI (Globally Unique Identifier), generated by the AMF
  allowedNSSAI:                            # Selected network slice
  - sliceDifferentiator: "000001"
    sliceType: eMBB
  conditions:
  - message: Registration successful       # Indicates overall regitreation success
    reason: RegistrationSuccessful
    status: "True"
    type: Ready
  - message: Validated                     # Indicates whether the spec is valid and allowed
    reason: Validated
    status: "True"
    type: Validated
  - message: UE successfully authenticated # Indicates whether encrypted security context could be established
    reason: AuthenticationSuccess
    status: "True"
    type: Authenticated
  - message: UE config successfully loaded # Indicates whether a UE config is available
    reason: ConfigReady
    status: "True"
    type: SubscriptionInfoRetrieved
  config: <full-UE-kubeconfig>
```

### Control loops

Registration resources are first processed by the AMF (Access and Mobility Management Function). Later steps involve the AUSF (Authentication Server Function) and the UDM (Unified Data Management) function.

Consider the below sequence diagram:

``` mermaid
sequenceDiagram
    UE->>+AMF: Create Registration
    Note right of AMF: Validate Registration spec
    AMF->>+AUSF: Create MobileIdentity
    Note right of AUSF: Map SUCI to SUPI and add to status
    AUSF->>-AMF: Return MobileIdentity status
    Note right of AMF: Genetate GUTI from SUPI
    Note right of AMF: Reject if SUPI or GUTI is missing
    AMF->>+UDM: Create Config
    Note right of UDM: Add UE config to Config status
    UDM->>-AMF: Return Config status
    Note right of AMF: Reject if no Config is returned
    Note right of AMF: Set Registration status
    AMF->>-UE: Return Registration status
    Note right of AMF: Maintain the active-registration table
```

The AMF control loops are as follows:
1. Control loop `register-input`. Purpose: validate AMF:Registration and write to internal state. Watches: AMF:Registration. Predicates: `GenerationChanged`. Writes to AMF:RegState (internal registration state).
   1. Create an empty AMF:RegState resource
   2. Initialize status fields.
   3. Check registration type. If not `initial`, set `Validated` status to `False` with reason `InvalidType`.
   4. Check 5GC/NR native mode. If not `n1Mode`, set `Validated` status to `False` with reason `StandardNotSupported`.
   5. Check mobile identity. If type is not `SUCI` or the value is empty, set `Validated` status to `False` with reason `SuciNotFound`.
   6. Check UE security capability. If the encryption algorithms list does not contain `5G-EA2` or the integrity algorithms list does not contain `5G-IA2`, set `Validated` status to `False` with reason `EncyptionNotSupported`.
   7. Otherwise set `Validated` status to `True` with reason `Validated`.
   8. Write AMF:RegState.
2. Control loop `register-identity-req`. Purpose: generate mobile identity requests for the AUSF. Watches: AMF:RegState. Predicates: runs only if the `Validated` status is `True`. Writes to: AUSF:MobileIdentity.
   1. Create an empty AUSF:MobileIdentity resource.
   2. Set the SUCI in the spec.
   3. Send to the AUSF.
3. Control loop `register-identity-handler`. Purpose: handle mobile identity responses from the AUSF. Watches: AMF:RegState and AUSF:MobileIdentity. Predicates: runs only if AMF:RegState `Validated` status is `True` and the MobileIdeintity is labeled `state:Ready`. Writes to: AMF:RegState.
   1. Join on metadata.
   2. Check is AUSF:MobileIdentity `Reeady` status is true. If not, set the `Authenticated` status to `False` with reason `SupiNotFound`.
   3. Genetate a GUTI based on the SUPI returned by the AUSF and add to the status.
   4. Set the AMF:RegState `Authenticated` status to `True` with reason `AuthenticationSuccess`.
   5. Write AMF:RegState.
4. Control loop `register-config-req`. Purpose: generate a config request to the UDM in order to obtain a secure context for the UE. Watches: AMF:RegState. Predicates: runs only if AMF:RegState `Authenticated` status is `True`. Writes to: UDM:Config.
   1. Create an empty UDM:Config resource
   2. Set metadata.
   3. Send to the UDM.
5. Control loop `register-config-handler`. Purpose: handle configs from the UDM. Watches: AMF:RegState and UDM:Config. Predicates: runs only if AMF:RegState `Authenticated` status is `True`. Writes to: AMF:RegState.
   1. Join on metadata.
   2. Check is UDM:Config `Reeady` status is true. If not, set the `SubscriptionInfoFound` status to `False` with reason `ConfigNotFound`.
   3. Otherwise add the config returned by the UDM to the status and the `SubscriptionInfoFound` status to `True` with reason `ConfigReady`.
   4. Write to AMF:RegState.
6. Control loop `register-output`. Purpose: write state maintained in the internal AMF:RegState back into the user-visible AMF:Registration resources. Watches: AMF:RegState. Predicates: runs only if AMF:RegState `SubscriptionInfoFound` status is `True`. Writes to: AMF:Registration.
   1. If each of the `Validated`, `Authenticated`, and `SubscriptionInfoFound` status is `True`, set the `Ready` status to `True` with reason `RegistrationSuccessful`. Otherwise set the `Ready` status to `False` with reason `RegistrationFailed`.
   2. Copy the `Validated` status from the internal state to the AMF:Registration resource status conditions.
   3. Copy the `Authenticated` status from the internal state to the AMF:Registration resource status conditions.
   4. Copy the `SubscriptionInfoFound` status from the internal state to the AMF:Registration resource status conditions.
   5. Copy the rest of the status fields from the AMF:RegState into the AMF:Registration status.
   6. Write to AMF:Registration.
7. Control loop `active-registration`. Purpose: maintain the `active-registration` table at the AMF. Watches: AMF:RegState. Predicates: runs only if AMF:RegState `Ready` status is `True`. Writes to: AMF:ActiveRegistrationTable.
   1. Create an empty AMF:ActiveRegistrationTable resource.
   2. Gather the name, namespace, GUTI and SUCI from all AMF:RegState resources into a list.
   3. Write registration list into the AMF:ActiveRegistrationTable.

The AUSF control loops are as follows:
1. Control loop `supi-req-handler`. Purpose: look up the SUPI based on the SUCI. Watches: AUSF:MobileIdentity. Predicates: `GenerationChanged`. Writes to: AUSF:MobileIdentity.
   1. Look up the SUPI based on the SUCI in the request. If successful, set the `Ready` status to `True` with reason `Ready`, otherwise set `Ready` to `False` with reason `MobileIdentityNotFound`.
   2. Set the label `state:Ready`
   3. Write status back to AUSF:MobileIdentity.

### Getting started

Init the operators using the production mode and assume again username is `user-1`.

1. Load the initial config of the UE:

   ```bash
   $ export KUBECONFIG=./user-1-initial.config
   ```

2. Optionally query the initial config. Observe only basic access rights are enabled for the UE, and only to the `registration` resource, only in their own namespace (`user-1`). This effectively isolates UEs from each other, preventing malicious UEs from modifying the registration state of other UEs.

   ```bash
   $ dctl get-config
   ðŸ‘¤ User Information:
      Username:   user-1
      Namespaces: [user-1]
      Rules: 1 RBAC policy rules
        [1] verbs=[create get list watch] apiGroups=[amf.view.dcontroller.io] resources=[registration]

   â±ï¸  Token Metadata:
      Issuer:     dcontroller
      Issued At:  ...
      Expires At: ...
      Not Before: ...
   âœ… Token is VALID
   ```

2. Register the UE at the AMF:

   ```bash
   $ kubectl apply -f workflows/registration/registration-user-1.yaml
   ```

3. Check registration status: you should get a valid `Ready` status (plus lots of other useful statuses):

   ```bash
   $ kubectl -n user-1 get registration user-1 -o jsonpath='{.status.conditions}'|jq .
   [
     {
       "message": "Registration successful",
       "reason": "RegistrationSuccessful",
       "status": "True",
       "type": "Ready"
     },
     {
       "message": "Validated",
       "reason": "Validated",
       "status": "True",
       "type": "Validated"
     },
     {
       "message": "UE successfully authenticated",
       "reason": "AuthenticationSuccess",
       "status": "True",
       "type": "Authenticated"
     },
     {
       "message": "UE config successfully loaded",
       "reason": "ConfigReady",
       "status": "True",
       "type": "SubscriptionInfoRetrieved"
     }
   ]
   ```

4. Load the config returned by the AMF. This should now allow fine-grained access policies beyond the basic registration workflow. In particular, the UE from now can create, watch, get and list Registration, Session and ContextRelease resources in their own namespace (`user-1`). 

   ```bash
   $ kubectl -n user-1 get registration user-1 -o jsonpath='{.status.config}' > ./user-1-full.config
   $ export KUBECONFIG=./user-1-full.config
   ```

   Check the new credentials:

   ```bash
   $ dctl get-config
   ...
   ```

5. In another terminal load the admin config and check the table maintaining the active registrations. Observe that the registration for `user-1` is added to the list

   ```bash
   $ export KUBECONFIG=./admin.config
   $ kubectl get activeregistrationtable --all-namespaces -o yaml
   apiVersion: v1
   items:
   - apiVersion: amf.view.dcontroller.io/v1alpha1
     kind: ActiveRegistrationTable
     metadata:
       name: active-registrations
       uid: f092b6bb-feed-e377-41e1-652ff1d962ed
     spec:
     - guti: test-guti-000000000000000
       name: test-registration
       namespace: test-registration
       suci: test-suci-000000000000000
     - guti: guti-310-170-3F-152-2A-B7C8D9E0
       name: user-1
       namespace: user-1
       suci: suci-0-999-01-02-4f2a7b9c8d13e7a5c0
   kind: List
   metadata:
     resourceVersion: ""
   ```

6. Optionally, clean up the registration:

   ```bash
   $ kubectl delete -f workflows/registration/registration-user-1.yaml
   ```

## Session establishment

### The Session resource

The Session resource is the main driver for creating UE sessions. The UE specifies the session parameters in the spec of the Registration resource and the AMF and the SMF will collaborate to set up the session and add a session status indicating the results. Note that Session resources cannot be created or listed with the initial UE configuration. Therefore, a valid registration foe the UE must exist for a session to be created. Note that multiple sessions (with different name and session id) can be created over a single Registration.

The below dump shows a full Session resource with a valid status set by the AMF:

``` yaml
apiVersion: amf.view.dcontroller.io/v1alpha1
kind: Session
metadata:
  name: user-1-1
  namespace: user-1
  annotations:
    interface: "N1-NAS-SM"              # Protocol interface this represents
spec:
  guti: guti-310-170-3F-152-2A-B7C8D9E0 # GUTI generated in the registration workflow
  idle: null                            # Indicates whether the session is idle (see later)
  nssai: eMBB                           # NSSAI targeted: SST 1: Enhanced Mobile Broadband (eMBB)
  sessionId: 1                          # Must be unique per UE, used to correlate all session messages
  pduSessionType: IPv4                  # PDU Session Type, enum: IPv4 | IPv6 | IPv4v6 | Ethernet | Unstructured
  # Service/Session Continuity for roaming, enum: SSC1 (anchor maintained) | SSC2 (released on move) | SSC3 (flexible)
  sscMode: SSC1
  networkConfiguration:                 # Network Configuration Requests (Protocol Configuration Options)
    requests:
    - addressFamily: IPv4               # Request #1: IP configuration via IPCP
      type: IPConfiguration
    - addressFamily: IPv4               # Request #2: DNS server addresses
      type: DNSServer
  qos:                                  # Quality Of Service SPECIFICATION
    flows:                              # QoS Flows: Define service quality characteristics
    - name: voice-flow                  # Flow 1: Voice flow for VoLTE/VoNR calls
      # Alternative semantic 5QI (5G Quality of Service Identifier) values:
      # - ConversationalVoice (5QI=1): Voice calls
      # - ConversationalVideo (5QI=2): Video calls, 150ms PDB
      # - RealTimeGaming (5QI=3): Gaming, 50ms PDB
      # - NonConversationalVideo (5QI=4): Streaming video, 300ms PDB
      # - IMSSignaling (5QI=5): SIP signaling, 100ms PDB
      # - Video (5QI=6,7,8,9): Various video streaming
      # - BestEffort (5QI=9): Default, no guarantees
      fiveQI: ConversationalVoice 
      bitRates:                         # bitrates, subjected to PCF policies
        downlinkBwKbps: 128
        uplinkBwKbps: 128
    - name: best-effort-flow            # Flow 2: Best effort for general data
      fiveQI: BestEffort
    rules:                              # QoS Rules: Packet classification for flow binding
    - name: voice-flow                  # Rule 1: Voice traffic (SIP + RTP)
      precedence: 10                    # Lower number = higher priority (1-255)
      qosFlow: voice-flow               # Reference to flow by name
      default: false                    # match-all: false
      filters:                          # Packet filters for this rule
      - name: sip-signaling
        direction: Bidirectional        # enum: Uplink | Downlink | Bidirectional
        match:
          type: IPFilter
          parameters:
            destinationPort: 5060
            protocol: UDP
      - name: rtp-voice
        direction: Bidirectional
        match:
          parameters:
          type: IPFilter
            destinationPortRange:
              end: 32767
              start: 16384
            protocol: UDP
    - name: default-rule                # Rule 2: Default rule (REQUIRED - exactly one per session)
      precedence: 255                   # Lowest priority
      qosFlow: best-effort-flow         # Reference to flow by name
      default: true                     # Exactly one rule must be default
      filters:
      - direction: Bidirectional
        match:
          type: MatchAll
        name: match-all
status:
  conditions:
  - message: Session successfully established # Session created
    reason: SessionSuccessful
    status: "True"
    type: Ready
  - message: Session request validated        # Session spec validated
    reason: Validated
    status: "True"
    type: Validated
  - message: PCF policies merged              # Policies obtained from the PCF
    reason: PolicyApplied
    status: "True"
    type: PolicyApplied
  - message: UPF configured                   # UPF config generated
    reason: UPFConfigured
    status: "True"
    type: UPFConfigured
  guti: guti-310-170-3F-152-2A-B7C8D9E0
  suci: suci-0-999-01-02-4f2a7b9c8d13e7a5c0
  networkConfiguration:                       # Generated network conciguration 
    dnsConfiguration:
      primaryDNS: 8.8.8.8
      secondaryDNS: 8.8.4.4
    ipConfiguration:
      defaultGateway: 10.45.0.1
      ipAddress: 10.45.0.100
      mtu: 1500
      subnetMask: 255.255.0.0
  qos:                                        # QoS policies processed through the PCF
    flows:
    - bitRates:
        downlinkBwKbps: 128
        uplinkBwKbps: 128
      fiveQI: ConversationalVoice
      name: voice-flow
    - fiveQI: BestEffort
      name: best-effort-flow
    rules:
    - default: false
      filters:
      - direction: Bidirectional
        match:
          parameters:
            destinationPort: 5060
            protocol: UDP
          type: IPFilter
        name: sip-signaling
      - direction: Bidirectional
        match:
          parameters:
            destinationPortRange:
              end: 32767
              start: 16384
            protocol: UDP
          type: IPFilter
        name: rtp-voice
      name: voice-rule
      precedence: 10
      qosFlow: voice-flow
    - default: true
      filters:
      - direction: Bidirectional
        match:
          type: MatchAll
        name: match-all
      name: default-rule
      precedence: 255
      qosFlow: best-effort-flow
```

### Control loops

Session resources are first processed by the AMF (Access and Mobility Management Function). Later steps involve the SMF (Session Management Function), the PCF (Policy Control Function), and the UPF (User Plane Function) function.

Consider the below sequence diagram:

``` mermaid
sequenceDiagram
    Note left of UE: Registration created
    UE->>+AMF: Create Session
    Note right of AMF: Validate Session spec
    AMF->>+SMF: Create SessionContext
    Note right of SMF: Process session through the policies obtained from the PCF
    Note right of SMF: Genetate IP and DNS configuration
    SMF->>UPF: Configure UPF with traffic spec
    SMF->>-AMF: Return SessionContext status
    Note right of SMF: Maintain the active-session table
    Note right of AMF: Copy status to Session
    AMF->>-UE: Return Session status
```

The AMF control loops are as follows:
1. Control loop `session-input`. Purpose: validate AMF:Session resources and write internal state. Watches: AMF:Session. Predicates: `GenerationChanged`. Writes to SMF:SessionContext (SMF internal session state).
   1. Create an empty SMF:SessionContext resource
   2. Initialize status fields.
   3. Check if network configuration request, QoS flows and QoS rules are present in the spec. If not, set `Validated` status to `False` with reason `InvalidSession`.
   4. Check if the selected network slice is `eMBB`. If not, set `Validated` status to `False` with reason `NSSAINotPermitted`.
   5. Check if the GUTI is present in the spec. If not, set `Validated` status to `False` with reason `GutiNotSpeficied`.
   6. Check if the active registration table contains the GUTI. If not, set `Validated` status to `False` with reason `Unregistered`.
   7. Look up the SUPI for the GUTI. If this fails, set `Validated` status to `False` with reason `SupiNotFound`.
   8. Otherwise set the `Validated` status to `True` with reason `Validated`.
   9. Set the GUTI, SUPI and SUCI in the status
   10. Write to the SMF:SessionContext resource
2. Control loop `session-output`. Purpose: write state maintained in the internal SMF:SessionContext back into the user-visible AMF:Session resource. Watches: AMF:SessionContext. Predicates: none. Writes to: AMF:Session.
   1. If each of the `Validated`, `PolicyApplied`, and `UPFConfigured` status is `True`, set the `Ready` status to `True` with reason `SessionSuccessful`. Otherwise set the `Ready` status to `False` with reason `SessionFailed`.
   2. Copy the `Validated` status from the internal state to the AMF:Session resource status conditions.
   3. Copy the `PolicyApplied` status from the internal state to the AMF:Session resource status conditions.
   4. Copy the `UPFConfigured` status from the internal state to the AMF:Session resource status conditions.
   5. Copy the rest of the status fields from the SMF:SessionContext into the AMF:Session status.
   4. Write to AMF:Session.

The SMF control loops are as follows:
1. Control loop `session-context-handler`. Purpose: query the PCF and apply the returned policies to the session spec. Watches: SMF:SessionContext. Predicates: none. Writes to SMF:SessionContext.
   1. Obtain session policies from the PCF
   2. Process QoS flows through the session policies; currently filters for `ConversationalVoice` and `BestEffort` 5QI (5G Quality of Service Identifier).
   3. Process QoS bitrates through the session policies; cap uplink/downlink bitrates at the values provided by the PCF.
   4. Check if `pduSessionType` is `IPv4`. If not, set `PolicyApplied` status to `False` with reason `AddressFamilyNotSupported`, otherwise set `PolicyApplied` status to `True` with reason `PolicyApplied`
   5. Check if an IP network configuration is requested. If yes, choose a random IP and set netmask, default gateway and MTU.
   6. Check if an DNS configuration is requested. If yes, set primary and secondary DNS server address.
   7. Check if IDLE state is request. If no, set status `UPFConfigured` to `True` with reason `UPFConfigured`, otherwise set `UPFConfigured` to `False` with reason `Idle`
   8. Write SMF:SessionContext
2. Control loop `upf-notifier`. Purpose: set session traffic spec in the UPF:Config. Watches: SMF:SessionContext. Predicates: runs only if SMF:SessionContext `Ready` status is `True`. Writes to UPF:Config.
   1. Create an empty UPF:Config resource
   2. Copy traffic spec from the SMF:SessionContext to the UPF:Concig
   3. Send UPF:Concig
3. Control loop `active-session`. Purpose: maintain the `active-session` table at the SMF. Watches: SMF:SessionContext. Predicates: runs only if SMF:SessionContext `Validated` and `PolicyApplied` status is `True`. Writes to: SMF:ActiveSessionTable.
   1. Create an empty SMF:ActiveSessionTable resource.
   2. Gather the name, namespace, GUTI and session id from all SMF:SessionContext resources into a list.
   3. Add the idle status in each list member
   4. Write session list into the SMF:ActiveSessionTable.
   
The UPF control loops are as follows:
1. Control loop `active-config`. Purpose: maintain the `active-config` table at the UPF. Watches: UPF:Config. Predicates: none. Writes to: UPF:ActiveConfigTable.
   1. Create an empty UPF:ActiveConfigTable resource.
   2. Gather the name, namespace, and traffic spec per each UPF:Config resources into a list.
   4. Write config list into the UPF:ActiveConfigTable resource.
   
### Getting started

Make sure a registration exists for the current user name and the full user config is loaded as above. We assume again that the username is `user-1`.

1. Create a session `user-1-1`:

   ```bash
   $ kubectl apply -f workflows/session/session-1-1.yaml
   ```

2. Check session status: you should get a valid `Ready` status (plus lots of other useful statuses):

   ```bash
   $ kubectl get session -n user-1 user-1-1 -o jsonpath='{.status.conditions}'|yq -P
   - message: Session successfully established
     reason: SessionSuccessful
     status: "True"
     type: Ready
   - message: Session request validated
     reason: Validated
     status: "True"
     type: Validated
   - message: PCF policies merged
     reason: PolicyApplied
     status: "True"
     type: PolicyApplied
   - message: UPF configured
     reason: UPFConfigured
     status: "True"
     type: UPFConfigured
  ```

3. The SMF should have created an UPF config for the session. Note that the user cannot access the UPF config, therefore we have to switch to admin access to see the details.

   ```bash
   $ export KUBECONFIG=./admin.config
   $ kubectl get config.upf -n user-1 user-1-1 -o yaml
   apiVersion: upf.view.dcontroller.io/v1alpha1
   kind: Config
   metadata:
     name: user-1-1
     namespace: user-1
   spec:
     networkConfiguration:
       dnsConfiguration:
         primaryDNS: 8.8.8.8
         secondaryDNS: 8.8.4.4
       ipConfiguration:
         defaultGateway: 10.45.0.1
         ipAddress: 10.45.0.100
         mtu: 1500
         subnetMask: 255.255.0.0
     qos:
       flows: ...
       rules: ...
   ```

4. Again, switching to admin access allows you to browse the active session list:

   ```bash
   $ export KUBECONFIG=./admin.config
   $ kubectl get activesessiontable --all-namespaces -o yaml
   apiVersion: v1
   items:
   - apiVersion: smf.view.dcontroller.io/v1alpha1
     kind: ActiveSessionTable
     metadata:
       name: active-sessions
       uid: e66bcdbc-90e8-ac13-fd3c-5dccb77a88a0
     spec:
     - guti: test-guti-000000000000000
       idle: false
       name: test-session
       namespace: test-session
       sessionId: 0
     - guti: guti-310-170-3F-152-2A-B7C8D9E0
       idle: false
       name: user-1-1
       namespace: user-1
       sessionId: 1
   kind: List
   metadata:
     resourceVersion: ""
   ```

## Session idle transition

### Getting started

Make sure a registration and a session exists for the `user-1` and the full user config is loaded.

1. Optionally, set up a watch for the UPF configs of `user-1`. This will dump a line every time we de-activate or activate a session for `user-1` (note that this requires admin access):

   ```bash
   $ kubectl get config.upf -n user-1 -w
   ```

2. Request an idle transition for session `user-1-1`.

   ```bash
   $ kubectl apply -f workflows/session/contextrelease-1-1.yaml
   ```

3. Check the status: you should get a valid `Ready` status:

   ```bash
   $ kubectl get contextrelease -n user-1 user-1-1 -o jsonpath='{.status.conditions}'|yq -P
   - message: Context release request accepted
     reason: Ready
     status: "True"
     type: Ready
  ```

  Meanwhile, the watch should dump a new line `user-1-1`, indicating that the UPF config for the `user-1-1` session has changed. Listing the actual UPF config will show that the config has gone.

   ```bash
   $ kubectl get config.upf -n user-1 user-1-1
   Error from server (NotFound): the server could not find the requested resource
   ```

4. You can re-activate the session by deleting the context release resource.

   ```bash
   $ kubectl delete -f workflows/session/contextrelease-1-1.yaml
   ```

   Again, the watch should dump a new line. Checking again the UPF configs (with admin access) will show the config for the session to re-appear, with exactly the same settings as before:

   ```bash
   kubectl get config.upf -n user-1 user-1-1 -o yaml
   apiVersion: upf.view.dcontroller.io/v1alpha1
   kind: Config
   metadata:
     name: user-1-1
     namespace: user-1
   spec:
     networkConfiguration:
       dnsConfiguration:
         primaryDNS: 8.8.8.8
         secondaryDNS: 8.8.4.4
       ipConfiguration:
         defaultGateway: 10.45.0.1
         ipAddress: 10.45.0.100
         mtu: 1500
         subnetMask: 255.255.0.0
     qos:
       flows: ...
       rules: ...
   ```

## License

MIT License
